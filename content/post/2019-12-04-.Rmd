---
title: 区块链双花攻击
author: Xiaohui Li
date: '2019-12-04'
slug: ''
categories:
  - blcokchain
tags:
  - bitcoin
---

\quad \quad 区块链中的双花攻击的建模，可以用酒鬼漫步的概率模型来描述：
![](/post/2019-12-04-_files/酒鬼漫步.png)


\quad \quad 记酒鬼向右一步的概率为$p$,向左的概率为$1- p = q$则当他处在$x = n$的位置的时候，最后掉入悬崖$x = 0$的概率为$p(n)$,其概率为：
$$p(n) = (\frac{q}{p})^{n}$$
具体证明为：考虑$p(1)$,即酒鬼走完第一步后，要么向左位于$x = 0$处(此事件的发生概率为$q$)，要么向右位于$x = 2$处（此事件的发生概率为$p$）,之后掉入悬崖，概率为：
$$p(1) =  (1- p) + p \times  p(2)$$

进一步分析，从$x = 2$最终到达$x = 1$（可以是任意多个步骤）,然后最终$x = 0$（可以是任意多个步骤）,事实上均是概率$p(1)$,因此：
$$p(2) = p(1)^{2}$$
联立上述两个方程，得到$p(1)$有意义的解为：$$p(1) = \frac{1-p}{p} = \frac{q}{p}$$
因此可得到：
$$p\left(n \right) = p(1)^{n} = (\frac{q}{p})^{n}$$
其实上述问题和区块链双花概率建模的情况是一样的，记录:
$p$ ：为诚实链挖出块挖出的概率；
$q$：为非诚实链挖出快的概率；
$p(n)$：即非诚实链落后$n$个块后，追上诚实链的概率（可以想象为诚实链挖出块表示向右移动一格，否则向左移动一格，追赶上表示到达$x = 0$状态），因此概率表达为：
$$ p(n)=\left\{
\begin{aligned}
 & 1\quad q > p \\
 & (\frac qp)^{n} \quad q\le p\\
\end{aligned}
\right.
$$
假定区块链攻击者潜在的进展服从泊松分布，其期望值为：
$$\lambda = z\frac qp$$
关于这一点的解释可以理解为：竞争的的回合为z个，每个回合的胜率比为$\frac qp$,因此分摊到每个回合的量为$z\frac qp$.因此竞争链追赶上的概率为：
$$\sum _{k = 0} ^{\infty}\frac{\lambda^ke^{-\lambda}}{k!}.\left\{
\begin{aligned}
 & 1\quad k > z \\
 & (\frac qp)^{z-k} \quad k\le z\\
\end{aligned}
\right.$$
整理上述公式：
$$
\begin{equation}
\begin{split}
p(n) & = \frac{\lambda^0e^{-\lambda}}{0!}(\frac{q}{p})^{z} + \frac{\lambda^1e^{-\lambda}}{1!}(\frac{q}{p})^{z-1}+
\cdots + \frac{\lambda^ze^{-\lambda}}{z!}(\frac{q}{p})^{z-z} + \frac{\lambda^ze^{-\lambda}}{(z+1)!}+ \cdots \\
 &=  \frac{\lambda^0e^{-\lambda}}{0!} + \frac{\lambda^1e^{-\lambda}}{1!}+ \cdots + \frac{\lambda^ze^{-\lambda}}{z!} + \frac{\lambda^ze^{-\lambda}}{(z+1)!}+ \cdots  - (\frac{\lambda^0e^{-\lambda}}{0!} + \frac{\lambda^1e^{-\lambda}}{1!}+\cdots + \frac{\lambda^ze^{-\lambda}}{z!}) + 
 \frac{\lambda^0e^{-\lambda}}{0!}(\frac{q}{p})^{z} + \frac{\lambda^1e^{-\lambda}}{1!}(\frac{q}{p})^{z-1} + \cdots + \frac{\lambda^ze^{-\lambda}}{z!}(\frac{q}{p})^{z-z}\\
 & = 
1 - \sum _{k = 0} ^{z}\frac{\lambda^ke^{-\lambda}}{k!}(1-(\frac qp)^{z-k})
\end{split}
\end{equation}
$$
相应的，我们探讨一下两种概率(两种前后的正、反的逻辑)：

1. 给定的概率$q$以及给定的落后的块数$z$,则最后攻击者成功的概率。

2. 给定的概率$q$,要诚实链领先多少块后，才能保证攻击者成功的概率不超过给定值。

问题1的仿真：
```{r}
library(magrittr)
options(scipen = 20)
mc_blockchain <- function(q,z){
  p <- 1-q
  lambda <- z*q/p
  pn <- 1 - sum(lambda^(0:z)*exp(-lambda)/factorial(0:z)*(1 - (q/p)^(z-(0:z))))
  return(pn)
}

p1 <- lapply(0:10, function(x) mc_blockchain(q = 0.1,x)) %>%
  unlist %>%
  round(10)
p1_df <- data.frame(z = 0:10,P = p1)
colnames(p1_df) <- c("Z","P")
knitr::kable(p1_df)
p2 <- lapply(seq(0,50,by = 5), function(x) mc_blockchain(q = 0.3,x)) %>%
  unlist %>%
  round(10)
p2_df <- data.frame(z = seq(0,50,by = 5),P = p2)
colnames(p2_df) <- c("Z","P")
knitr::kable(p2_df)
```

问题2的仿真：
```{r}
mc_z <- function(p,q){
  z <- 0
  while (TRUE) {
    pn <- mc_blockchain(q = q,z = z)
    if(pn <= p){
      break
    } else{
      z <- z + 1
    }
  }
  return(z)
}
z1 <- lapply(X = seq(0.1,0.42,by = 0.01),FUN = function(x) mc_z(p = 0.1/100,q = x)) %>%
  unlist
df_z1 <- data.frame(q = seq(0.1,0.42,by = 0.01),z = z1)
knitr::kable(df_z1)
```

